---
title: "R Camp - Day 4 Homework"
author: "Emily Elia"
date: "8/22/2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Disclaimer...

I know that this model is not correctly modeling what I want it to. I didn't have time to get it right before the 2:30 deadline. This code will run "correctly" and produce plots, but it is not producing the right distributions.


# Problem 1 - Quantitatively Predictive Model 

## Research Question

I model the likelihood of a corrupt incumbent politican getting voted out of 
office by the electorate. I base my model on an ongoing project about corruption,
party identity, and voting behavior. I tackle the puzzle of why corrupt politicians 
often get re-elected, especially when surveys and experiments show that the majority
of citizens oppose corruption and act electorally to vote it out in lab/survey
settings. Why does this not translate into the "real world?" I argue that examining
this puzzle often leaves out an important factor in a voter's decision-making
process: the opposition. Even if a voter dislikes corruption, an undesirable 
oppostion may drive them to continute to vote for the incumbent candidate as a 
"lesser of two evils." I argue that the more idealogically distant an opposition 
candidate is from the incumbent, the more likley the incumbent will be to remain 
in office because voters will not have a viable alternative to vote for in place of
the corrupt incumbent. However, if the opposition is ideologically closer to the
incumbent, then voters have an option that is more likely to satisfy their 
preferences. Therefore, they'll electorally punish the corrupt incumbent by 
moving their vote to the oppostion.

## Theoretical Variable Ranges

Theoretically, ideology is often measured on a left-right scale that typically ranges from 1 (extreme left) to 10 (extreme right). The ideological distance between an incumbent and an opposition would be the difference between the incumbent's ideological placement and the oppostion's ideological placement. This variable would range from 0 to 9, as the placements could be identical, which would yield a difference of 0, or the placements could be at opposite ends of the scale, which would yield a difference of 9. 

Many different scales and measurements can capture how peope feel about corruption in their governments. Corruption perceptions can be measured on surveys with categorical answers, such as "Corruption in government is: uncommon, somewhat uncommon, common, etc." Corruption perceptions can also be measured like an index where someone "ranks" the prevalence of corruption on a scale from 0 to 100. In this exercise, for simplicity of simulating data, I will measure voters' corruption perceptions on a scale from 0 to 100, where 0 indicates that a person believes their government contains absolutely no corruption and 100 indicates that a person believers their government is completely corrupt.

Formally,
P_{V} = F ((alpha{V} * delta_{V}) + (beta{V} * -epsilon_{V}))

alpha = parameter, how much a corruption perception matters to a voter

delta = voter's corruption perception

beta = parameter, how much ideological difference matters to a voter

epsilon = ideological distance between incumbent and oppostion 

P_{V} = likelihood voter will vote for oppostion over corrupt candidate

F =  some cumulative distribution function


H1: Voters have a dislike for corruption, or, in other words, corruption would
hurt their utility function, so voters do not want a corrupt politician in office
H2: Voters have ideological preferences, and these can take precedence over their
dislike for corruption and cause them to vote for the corrupt candidate despite 
the claim in H1 being true


## Constructing A Model

```{r model}

delta = seq(from=0,to=100,by=0.5)    # corruption perceptions
alpha = 3*delta                  # Weight parameter of perceptions

epsilon = seq(from=0,to=9,by=0.5)     # ideological differences
beta = 4*epsilon             # weight parameter of perceptions

par(mfrow=c(1,2))
plot(alpha ~ delta, type="l", col="firebrick4", lwd=3, 
     xlab=expression(delta[it]), ylab=expression(alpha[it]),
     main=expression(paste("Corruption Perception Parameter ", (alpha[it]), sep=" ")))
abline(v=0.5, lty=2, col="dimgray")
plot(beta ~ epsilon, type="l",  col="firebrick4", lwd=3,
     xlab=expression(epsilon[it]), ylab=expression(beta[it]), ylim=c(-50,50),
     main=expression(paste("Ideology Difference Parameter ", (beta[it]), sep=" ")))
abline(v=0.5, lty=2, col="dimgray"); abline(h=0, lty=2, col="dimgray")
```


## Looping for Plots

```{r plot loop}

# Create similar plots under different conditions
# We use a loop for this purpose

  # Run from here all the way down
  rm(list=ls())
  par(mfrow=c(4,3), mar = c(3, 3, 2, 2)) # Default (5,4,4,2) c(bottom, left, top, right)
  

for(i in 0:10){                              # We explore 0 to 10 in epsilon

    epsilon_val = i * 0.5                       # Parameters to be varied
    SD = 5                                    # Parameters to be varied
    SD_small = 2                               # Parameters to be varied
    SD_large = 8                              # Parameters to be varied
        
    
    epsilon_val = 3.0 # tuning parameter (ideology)
    
    epsilon = seq(from=0,to=9,by=0.5)    #ideology difference
    delta = seq(from=0,to=100,by=0.5)    # corruption perceptions
    alpha = 3*delta                  # Weight parameter of perceptions
    beta = 4*epsilon_val             # weight parameter of perceptions

    q = (alpha * delta) * (beta * epsilon_val)
  
   
    prob  <- pnorm(q=q, mean=0, sd=SD)         # Probability of voting
    prob2 <- pnorm(q=q, mean=0, sd=SD_small)   # Probability of voting
    prob3 <- pnorm(q=q, mean=0, sd=SD_large)   # Probability of voting
    prob4 <- pnorm(q=q, mean=-20, sd=SD_small) # Probability of voting
    
    plot(prob ~ delta, type="l", lwd=2, ylim=c(0,1), ylab="", 
        xlab=expression(Delta), cex.main=1.5,  
        main=substitute(paste(epsilon, sep=" = ", v), list(v=epsilon_val)))
    lines(prob2 ~ delta, type="l", lty=2, col="firebrick", lwd=2)
    lines(prob3 ~ delta, type="l", lty=3, col="navy", lwd=2)
    lines(prob4 ~ delta, type="l", lty=4, col="forestgreen", lwd=2)
     }         

  # We want to put a legend on this combined graph
  plot(1, type = "n", axes=FALSE, xlab="", ylab="") # No plotting
  legend(x = "topleft", 
         legend = c("Normal(0,17)", "Normal(0,8)", "Normal(0,25)",
                    "Normal(-20,8)"), 
         col=c("black", "firebrick", "navy", "forestgreen"),
         lty=c(1,2,3,4), ncol=2,
         lwd=2, cex=1.1, horiz = FALSE, text.width=0.2, box.col = "white")   
```


# Problem 2 - Building A Function For the Model

```{r function}

# Building a function for the model #

PredModel<- function(xvar1, xvar2, setx2, SD){ 
  #variable 1, variable 2, setx x variable 2, standard deviation)
  
  alpha #para1
  delta <- xvar1
  beta #para2
  epsilon <- xvar2 
  epsilon_val <- setx2
  SD <- SD
  q #dist

  delta = seq(from=0,to=100,by=0.5)    # corruption perceptions
  alpha = 3*delta                  # Weight parameter of perceptions
  
  epsilon = seq(from=0,to=9,by=0.5)     # ideological differences
  beta = 4*epsilon             # weight parameter of perceptions
  
  q = (alpha * delta) * (beta * epsilon_val)
  
  prob  <- pnorm(q=q, mean=0, sd=SD)         # Probability of voting
  
  plot(prob ~ delta, type="l", lwd=2, ylim=c(0,1), ylab="", 
       xlab=expression(Delta), cex.main=1.5,  
       main=substitute(paste(epsilon, sep=" = ", v), list(v=epsilon_val)))
  
  return(q)
  
  }

PredModel(delta, epsilon, epsilon_val, 2)

```
